(defun Start-lexer(str)
	(let ((lst (str-to-list str)))
		(map nil #'(lambda (lex) (print (lexize lex (lexlst)))) lst)
	)
)
(defun split-space (string &key (is-spacep #'is-spacep))
	(loop :for start = (position-if-not is-spacep string)
    	:then (position-if-not is-spacep string :start (1+ end))
    	:for end = (and start (position-if is-spacep string :start start))
    	:when start :collect (subseq string start end)
    	:while end
	)
)
(defun lst-parser-str (lst)
    (format nil "~{~a~}" lst)
)
(defun delete-space (str)
	(let ((Delete-space '(#\Space #\Newline)))
	(string-trim Delete-space str))
)
(defun Read-Line-Console()
	(loop
        (format t "~%Enter a string: ")
        (Start-lexer (read-line))
    )		
)
(defun is-spacep (c) (char= c #\Space))
(defun lexlst ()
	(let((lex-key '("and" "or" "not" "equal" "less" "nil" "list" "append" "concat" "set" "deffun" "for" "if"  "exit" "load" "disp" "true" "false" "+" "-"  "/" "*" "(" ")" "**" ","))
	(lex-value '("KW_AND" "KW_OR" "KW_ NOT" "KW_EQUAL" "KW_LESS"  "KW_NIL" "KW_LIST" "KW_APPEND" "KW_CONCAT" "KW_SET"  "KW_DEFFUN" "KW_FOR" "KW_IF" "KW_EXIT" "KW_LOAD"  "KW_DISP" "KW_TRUE" " KW_FALSE" "OP_PLUS" "OP_MINUS" "OP_DIV" "OP_MULT" "OP_OP" "OP_CP" "OP_DBLMULT" "OP_COMMA")))
	(pairlis lex-key lex-value)
	)
)
(defun str-to-list (str)
	(setq str (lst-parser-str (map 'list #'(lambda (c) 
	(if (find-brack c) (concatenate 'string " " (string c) " ") 
	(string c))) (delete-space str))))
	(setq length1 (- (length str) 1))
	(let ((lst (loop for i from 0 to length1 when (char= (aref str i) #\") collect i)) (i1 '()) (i2 '()) (space-i '()))
	(loop while lst do (setq i1 (car lst)) do (setq i2 (car (cdr lst)))do (setq lst (cdr (cdr lst)))do (setq space-i
	(loop for i from 0 to (- (length str) 1) when (and (> i i1) (< i i2) (char= (aref str i) #\Space)) collect i)))
	(setq length1 (- (length str) 1))
	(split-space (lst-parser-str
	(loop for i from 0 to length1
	if (member i space-i) collect #\. else collect (aref str i)))))
)
(defun lexize (lex lst)
	 (let ((c (string (char lex 0)))) 
	 (cond ((find-alpha c) (id-lex lex lst))  
	 	   ((find-numeric c) (value-lex lex))
	 	   (t (if (op-lex lex lst) 				
	 	   (op-lex lex lst) (syntax-error))			
	 	   )
		)
	 )
)
(defun op-lex (lex lst)
	 (find-id lex)
)
(defun find-numeric (chr)
	(let ((c (char-int (coerce chr 'character))))
		(and (>= c (char-int #\0)) (<= c (char-int #\9))))
)
(defun find-alpha (chr)
	(let ((c (char-int (coerce chr 'character))))
		(and (>= c (char-int #\A)) (<= c (char-int #\z))))
)	 	   									 
(defun id-lex (lex lst)
	(assert (find-alpha (string (char lex 0))))
	(loop for c across lex 
		do (if (not (or (find-alpha c) (find-numeric c))) 
		(return-from id-lex (syntax-error))))

	(let ((kw (kw-lex lex lst)))
		(if (null kw) (format nil "IDENTIFIER") kw))
)
(defun find-brack(chr)
	(let ((c (char-int (coerce chr 'character))))
		(or (= c 40) (= c 41)))
)
(defun find-id(str)
    (setf s (string-downcase str))
    (cond
		((string= s "and") (format nil "KW_AND"))
        ((string= s "or") (format nil "KW_OR"))
        ((string= s "not") (format nil "KW_NOT"))
        ((string= s "equal") (format nil "KW_EQUAL"))
        ((string= s "less") (format nil "KW_LESS"))
        ((string= s "nil") (format nil "KW_NIL"))
        ((string= s "list") (format nil "KW_LIST"))
        ((string= s "append") (format nil "KW_APPEND"))
        ((string= s "concat") (format nil "KW_CONCAT"))
        ((string= s "set") (format nil "KW_SET"))
        ((string= s "deffun") (format nil "KW_DEFFUN"))
        ((string= s "for") (format nil "KW_FOR"))
        ((string= s "if") (format nil "KW_IF"))
        ((string= s "exit") (format nil "KW_EXIT"))
        ((string= s "load") (format nil "KW_LOAD"))
        ((string= s "disp") (format nil "KW_DISP"))
        ((string= s "true") (format nil "KW_TRUE"))
        ((string= s "false") (format nil "KW_FALSE"))
        ((string= s "+") (format nil "OP_PLUS"))
        ((string= s "-") (format nil "OP_MINUS"))
        ((string= s "/") (format nil "OP_DIV"))
        ((string= s "(") (format nil "OP_OP"))
        ((string= s ")") (format nil "OP_CP"))
        ((string= s "\"") (format nil "OP_OC"))
        ((string= s ",") (format nil "OP_COMMA"))
        ((string= s "**") (format nil "OP_DBMULT"))
		((string= s "*") (format nil "OP_MULT"))
        (T NIL)
    )
)
(defun kw-lex (lex lst)
	 (find-id lex)
)
(defun value-lex (lex)
	(assert (find-numeric (string (char lex 0))))
	(if (and (> (length lex) 1) (find-zero (substring lex 0 1))) (return-from value-lex (syntax-error)))
	(loop for c across lex do (if (not (find-numeric c)) (return-from value-lex (syntax-error))))
	(format nil "VALUE")
)
(defun syntax-error ()
	(format nil "SYNTAX ERROR")
)
(defun lst-parser-str (lst)
    (format nil "~{~a~}" lst)
)
(defun find-zero (chr)
	(eq (char-code (coerce chr 'character)) 48)
)
(defun gppinterpreter()
	(Read-Line-Console)
)
